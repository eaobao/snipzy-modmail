import { CommandConfig, CommandDefinition, CommandManagerOptions, CommandMatchResult, MatchedCommand, Parameter, TypeConverterFn } from "./types";
export declare class CommandManager<TFilterContext = null> {
    protected commands: CommandDefinition<TFilterContext>[];
    protected defaultPrefix: RegExp | null;
    protected types: {
        [key: string]: TypeConverterFn;
    };
    protected defaultType: string;
    protected commandId: number;
    constructor(opts: CommandManagerOptions);
    /**
     * Adds a command to the manager.
     *
     * Examples:
     *
     * add("add", "<first:number> <second:number>")
     *   Adds a command called "add" with two required arguments.
     *   These arguments are added in an easily-readable string format.
     *
     * add("echo", [{name: "text", type: "string", catchAll: true}])
     *   Adds a command with a required argument "text" that captures the entire rest of the arguments.
     *   These arguments are added in a more programmable, array of objects format.
     *
     * add("mul", "<numbers:number...>")
     *   Adds a command with a required, repeatable argument "numbers".
     */
    add(trigger: string | RegExp, parameters?: string | Parameter[], config?: CommandConfig<TFilterContext>): CommandDefinition<TFilterContext>;
    remove(defOrId: CommandDefinition<TFilterContext> | number): void;
    /**
     * Find the first matching command in the given string, if any.
     * This function returns a promise to support async types and filter functions.
     */
    findMatchingCommand(str: string, ...context: TFilterContext extends null ? [null?] : [TFilterContext]): Promise<MatchedCommand<TFilterContext> | {
        error: string;
    } | null>;
    protected parseParameterString(str: string): Parameter[];
    /**
     * Attempts to match the given command to a string.
     */
    protected tryMatchingCommand(command: CommandDefinition<TFilterContext>, str: string): Promise<CommandMatchResult<TFilterContext> | null>;
    protected convertToArgumentType(value: any, type: any): any;
}
