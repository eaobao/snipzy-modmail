"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const escape_string_regexp_1 = __importDefault(require("escape-string-regexp"));
const defaultParameterTypes_1 = require("./defaultParameterTypes");
const parseArguments_1 = require("./parseArguments");
const TypeConversionError_1 = require("./TypeConversionError");
const paramDefinitionSimpleRegex = /[<\[].*?[>\]]/g;
const paramDefinitionRegex = new RegExp("[<\\[]" +
    "([a-z0-9]+?)" + // (1) Argument name
    "(?:\\:([a-z]+?))?" + // (2) Argument type
    "(?:=(.+?))?" + // (3) Default value
    "(\\.\\.\\.)?" + // (4) "..." to mark argument as a rest argument
    "(\\$)?" + // (5) "$" to mark the argument as a "catch-all" for the rest of the arguments (will be returned as the full string, unlike "...")
    "[>\\]]", "i");
const optMatchRegex = /^--([^\s-]\S*?)(?:=(.+))?$/;
const optShortcutMatchRegex = /^-([^\s-]+?)(?:=(.+))?$/;
const defaultParameter = {
    required: true,
    def: null,
    rest: false,
    catchAll: false
};
class CommandManager {
    constructor(opts) {
        this.commands = [];
        this.defaultPrefix = null;
        this.commandId = 0;
        if (opts.prefix != null) {
            const prefix = typeof opts.prefix === "string" ? new RegExp(escape_string_regexp_1.default(opts.prefix), "i") : opts.prefix;
            this.defaultPrefix = new RegExp(`^${prefix.source}`, prefix.flags);
        }
        this.types = opts.types || defaultParameterTypes_1.defaultParameterTypes;
        this.defaultType = opts.defaultType || "string";
        if (!this.types[this.defaultType]) {
            throw new Error(`Default type "${this.defaultType}" not found in types!`);
        }
    }
    /**
     * Adds a command to the manager.
     *
     * Examples:
     *
     * add("add", "<first:number> <second:number>")
     *   Adds a command called "add" with two required arguments.
     *   These arguments are added in an easily-readable string format.
     *
     * add("echo", [{name: "text", type: "string", catchAll: true}])
     *   Adds a command with a required argument "text" that captures the entire rest of the arguments.
     *   These arguments are added in a more programmable, array of objects format.
     *
     * add("mul", "<numbers:number...>")
     *   Adds a command with a required, repeatable argument "numbers".
     */
    add(trigger, parameters = [], config = {}) {
        // If we're overriding the default prefix, convert the new prefix to a regex (or keep it as null for no prefix)
        let prefix = this.defaultPrefix;
        if (config.prefix !== undefined) {
            if (config.prefix === null) {
                prefix = null;
            }
            else if (typeof config.prefix === "string") {
                prefix = new RegExp(`^${escape_string_regexp_1.default(config.prefix)}`, "i");
            }
            else {
                prefix = new RegExp(`^${config.prefix.source}`, config.prefix.flags);
            }
        }
        // Combine all triggers (main trigger + aliases) to a regex
        const triggers = [trigger];
        if (config && config.aliases)
            triggers.push(...config.aliases);
        const regexTriggers = triggers.map(trigger => {
            if (typeof trigger === "string") {
                return new RegExp(`^${escape_string_regexp_1.default(trigger)}(?=\\s|$)`, "i");
            }
            return new RegExp(`^${trigger.source}(?=\\s|$)`, trigger.flags);
        });
        // If parameters are provided in string format, parse it
        if (typeof parameters === "string") {
            parameters = this.parseParameterString(parameters);
        }
        else if (parameters == null) {
            parameters = [];
        }
        parameters = parameters.map(obj => Object.assign({ type: this.defaultType }, defaultParameter, obj));
        // Validate parameters to prevent unsupported behaviour
        let hadOptional = false;
        let hadRest = false;
        let hadCatchAll = false;
        parameters.forEach(param => {
            if (!this.types[param.type]) {
                throw new Error(`Unknown parameter type: ${param.type}`);
            }
            if (!param.required) {
                if (hadOptional) {
                    throw new Error(`Can only have 1 optional parameter to avoid ambiguity`);
                }
                hadOptional = true;
            }
            else if (hadOptional) {
                throw new Error(`Optional parameter must come last`);
            }
            if (hadRest) {
                throw new Error(`Rest parameter must come last`);
            }
            if (param.rest) {
                hadRest = true;
            }
            if (hadCatchAll) {
                throw new Error(`Catch-all parameter must come last`);
            }
            if (param.catchAll) {
                hadCatchAll = true;
            }
        });
        // Actually add the command to the manager
        const id = ++this.commandId;
        const definition = {
            id,
            prefix,
            triggers: regexTriggers,
            parameters,
            options: (config && config.options) || [],
            preFilters: (config && config.preFilters) || [],
            postFilters: (config && config.postFilters) || []
        };
        this.commands.push(definition);
        // Return a function to remove the command
        return definition;
    }
    remove(defOrId) {
        const indexToRemove = typeof defOrId === "number" ? this.commands.findIndex(cmd => cmd.id === defOrId) : this.commands.indexOf(defOrId);
        if (indexToRemove !== -1)
            this.commands.splice(indexToRemove, 1);
    }
    /**
     * Find the first matching command in the given string, if any.
     * This function returns a promise to support async types and filter functions.
     */
    async findMatchingCommand(str, ...context) {
        let onlyErrors = true;
        let lastError = null;
        const filterContext = context[0];
        for (const command of this.commands) {
            if (command.preFilters.length) {
                let passed = false;
                for (const filter of command.preFilters) {
                    passed = await filter(command, filterContext);
                    if (!passed)
                        break;
                }
                if (!passed)
                    continue;
            }
            const matchResult = await this.tryMatchingCommand(command, str);
            if (matchResult === null)
                continue;
            if (matchResult.error !== undefined) {
                lastError = matchResult.error;
                continue;
            }
            onlyErrors = false;
            if (command.postFilters.length) {
                let passed = false;
                for (const filter of command.postFilters) {
                    passed = await filter(matchResult.command, filterContext);
                    if (!passed)
                        break;
                }
                if (!passed)
                    continue;
            }
            return matchResult.command;
        }
        if (onlyErrors && lastError !== null) {
            return { error: lastError };
        }
        return null;
    }
    parseParameterString(str) {
        const parameterDefinitions = str.match(paramDefinitionSimpleRegex) || [];
        return parameterDefinitions.map((parameterDefinition, i) => {
            const details = parameterDefinition.match(paramDefinitionRegex);
            if (!details) {
                throw new Error(`Invalid argument definition: ${parameterDefinition}`);
            }
            let defaultValue = details[3];
            const isRest = details[4] === "...";
            const isOptional = parameterDefinition[0] === "[" || defaultValue != null;
            const isCatchAll = details[5] === "$";
            if (isRest) {
                defaultValue = [];
            }
            return {
                name: details[1],
                type: details[2] || "string",
                required: !isOptional,
                def: defaultValue,
                rest: isRest,
                catchAll: isCatchAll
            };
        });
    }
    /**
     * Attempts to match the given command to a string.
     */
    async tryMatchingCommand(command, str) {
        if (command.prefix) {
            const prefixMatch = str.match(command.prefix);
            if (!prefixMatch)
                return null;
            str = str.slice(prefixMatch[0].length);
        }
        let matchedTrigger = false;
        for (const trigger of command.triggers) {
            const triggerMatch = str.match(trigger);
            if (triggerMatch) {
                matchedTrigger = true;
                str = str.slice(triggerMatch[0].length);
            }
        }
        if (!matchedTrigger)
            return null;
        const parsedArguments = parseArguments_1.parseArguments(str);
        const args = {};
        const opts = {};
        let paramIndex = 0;
        for (let i = 0; i < parsedArguments.length; i++) {
            const arg = parsedArguments[i];
            if (!arg.quoted) {
                // Check if the argument is an --option
                // Both --option=value and --option value syntaxes are supported;
                // in the latter case we consume the next argument as the value
                const fullOptMatch = arg.value.match(optMatchRegex);
                if (fullOptMatch) {
                    const optName = fullOptMatch[1];
                    const opt = command.options.find(o => o.name === optName);
                    if (!opt) {
                        return { error: `Unknown option: --${optName}` };
                    }
                    let optValue = fullOptMatch[2];
                    if (opt.flag) {
                        if (optValue) {
                            return { error: `Flags can't have values: --${optName}` };
                        }
                        optValue = true;
                    }
                    else if (optValue == null) {
                        // If we're not a flag, and we don't have a =value, consume the next argument as the value instead
                        const nextArg = parsedArguments[i + 1];
                        if (!nextArg) {
                            return { error: `No value for option: --${optName}` };
                        }
                        optValue = nextArg.value;
                        // Skip the next arg in the loop since we just consumed it
                        i++;
                    }
                    opts[opt.name] = {
                        option: opt,
                        value: optValue
                    };
                    continue;
                }
                // Check if the argument is a string of option shortcuts, i.e. -abcd
                // The last option can have a value with either -abcd=value or -abcd value;
                // in the latter case we consume the next argument as the value
                const optShortcutMatch = arg.value.match(optShortcutMatchRegex);
                if (optShortcutMatch) {
                    const shortcuts = [...optShortcutMatch[1]];
                    const lastValue = optShortcutMatch[2];
                    const optShortcuts = command.options.reduce((map, opt) => {
                        if (opt.shortcut)
                            map[opt.shortcut] = opt;
                        return map;
                    }, {});
                    const matchingOpts = shortcuts.map(s => optShortcuts[s]);
                    const unknownOptShortcutIndex = matchingOpts.findIndex(o => o == null);
                    if (unknownOptShortcutIndex !== -1) {
                        return { error: `Unknown option shortcut: -${shortcuts[unknownOptShortcutIndex]}` };
                    }
                    for (let j = 0; j < matchingOpts.length; j++) {
                        const opt = matchingOpts[j];
                        const isLast = j === matchingOpts.length - 1;
                        if (isLast) {
                            if (opt.flag) {
                                if (lastValue) {
                                    return { error: `Flags can't have values: -${opt.shortcut}` };
                                }
                                opts[opt.name] = {
                                    option: opt,
                                    value: true
                                };
                            }
                            else {
                                if (lastValue) {
                                    opts[opt.name] = {
                                        option: opt,
                                        value: lastValue
                                    };
                                    continue;
                                }
                                // If we're not a flag, and we don't have a =value, consume the next argument as the value instead
                                const nextArg = parsedArguments[i + 1];
                                if (!nextArg) {
                                    return { error: `No value for option: -${opt.shortcut}` };
                                }
                                opts[opt.name] = {
                                    option: opt,
                                    value: nextArg.value
                                };
                                // Skip the next arg in the loop since we just consumed it
                                i++;
                            }
                        }
                        else {
                            if (!opt.flag) {
                                return { error: `No value for option: -${opt.shortcut}` };
                            }
                            opts[opt.name] = {
                                option: opt,
                                value: true
                            };
                        }
                    }
                    continue;
                }
            }
            // Argument wasn't an option, so match it to a parameter instead
            const param = command.parameters[paramIndex];
            if (!param) {
                return { error: `Too many arguments` };
            }
            if (param.rest) {
                const restArgs = parsedArguments.slice(i);
                if (param.required && restArgs.length === 0) {
                    return { error: `Missing required argument: ${param.name}` };
                }
                args[param.name] = {
                    parameter: param,
                    value: restArgs.map(a => a.value)
                };
                break;
            }
            if (param.catchAll) {
                args[param.name] = {
                    parameter: param,
                    value: str.slice(arg.index)
                };
                break;
            }
            args[param.name] = {
                parameter: param,
                value: arg.value
            };
            paramIndex++;
        }
        // Verify we have all required options and arguments and add default values
        for (const opt of command.options) {
            if (args[opt.name] != null)
                continue;
            if (opt.flag)
                continue;
            if (opt.required) {
                return { error: `Missing required option: ${opt.name}` };
            }
            if (opt.def) {
                opts[opt.name] = {
                    option: opt,
                    value: opt.def,
                    usesDefaultValue: true
                };
            }
        }
        for (const param of command.parameters) {
            if (args[param.name] != null)
                continue;
            if (param.required) {
                return { error: `Missing required argument: ${param.name}` };
            }
            if (param.def) {
                args[param.name] = {
                    parameter: param,
                    value: param.def,
                    usesDefaultValue: true
                };
            }
        }
        // Convert types
        for (const arg of Object.values(args)) {
            if (arg.usesDefaultValue)
                continue;
            try {
                if (arg.parameter.rest) {
                    arg.value = arg.value.map(v => this.convertToArgumentType(v, arg.parameter.type || this.defaultType));
                }
                else {
                    arg.value = this.convertToArgumentType(arg.value, arg.parameter.type || this.defaultType);
                }
            }
            catch (e) {
                if (e instanceof TypeConversionError_1.TypeConversionError) {
                    return { error: `Could not convert argument ${arg.parameter.name} to type ${arg.parameter.type}` };
                }
                throw e;
            }
        }
        for (const opt of Object.values(opts)) {
            if (opt.option.flag)
                continue;
            if (opt.usesDefaultValue)
                continue;
            try {
                opt.value = this.convertToArgumentType(opt.value, opt.option.type || this.defaultType);
            }
            catch (e) {
                if (e instanceof TypeConversionError_1.TypeConversionError) {
                    return { error: `Could not convert option ${opt.option.name} to type ${opt.option.type}` };
                }
                throw e;
            }
        }
        return {
            command: {
                ...command,
                args,
                opts
            }
        };
    }
    convertToArgumentType(value, type) {
        return this.types[type](value);
    }
}
exports.CommandManager = CommandManager;
